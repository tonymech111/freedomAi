;; InfoFi Token (Jetton) Smart Contract
;; Represents tokenized information assets on TON blockchain

#include "stdlib.fc";

;; Storage structure
;; total_supply - total token supply
;; admin_address - contract admin
;; content - token metadata (name, symbol, etc.)
;; jetton_wallet_code - code for individual wallet contracts

(int, slice, cell, cell) load_data() inline {
    slice ds = get_data().begin_parse();
    return (
        ds~load_coins(),      ;; total_supply
        ds~load_msg_addr(),   ;; admin_address
        ds~load_ref(),        ;; content
        ds~load_ref()         ;; jetton_wallet_code
    );
}

() save_data(int total_supply, slice admin_address, cell content, cell jetton_wallet_code) impure inline {
    set_data(begin_cell()
        .store_coins(total_supply)
        .store_slice(admin_address)
        .store_ref(content)
        .store_ref(jetton_wallet_code)
        .end_cell()
    );
}

;; Mint new info tokens
() mint_tokens(slice to_address, int amount, cell info_metadata) impure {
    var (total_supply, admin_address, content, jetton_wallet_code) = load_data();
    
    ;; Update total supply
    total_supply += amount;
    
    ;; Save updated data
    save_data(total_supply, admin_address, content, jetton_wallet_code);
    
    ;; Send tokens to recipient
    var msg = begin_cell()
        .store_uint(0x18, 6)
        .store_slice(to_address)
        .store_coins(amount)
        .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)
        .store_ref(info_metadata)
        .end_cell();
    
    send_raw_message(msg, 1);
}

;; Burn tokens
() burn_tokens(int amount) impure {
    var (total_supply, admin_address, content, jetton_wallet_code) = load_data();
    
    throw_unless(120, total_supply >= amount);
    total_supply -= amount;
    
    save_data(total_supply, admin_address, content, jetton_wallet_code);
}

;; Get token info
(int, slice, cell) get_jetton_data() method_id {
    var (total_supply, admin_address, content, _) = load_data();
    return (total_supply, admin_address, content);
}

;; Main receiver
() recv_internal(int msg_value, cell in_msg_full, slice in_msg_body) impure {
    if (in_msg_body.slice_empty?()) {
        return ();
    }
    
    slice cs = in_msg_full.begin_parse();
    int flags = cs~load_uint(4);
    
    if (flags & 1) {
        return ();
    }
    
    slice sender_address = cs~load_msg_addr();
    
    int op = in_msg_body~load_uint(32);
    
    ;; Mint operation (admin only)
    if (op == 1) {
        var (_, admin_address, _, _) = load_data();
        throw_unless(401, equal_slices(sender_address, admin_address));
        
        slice to_address = in_msg_body~load_msg_addr();
        int amount = in_msg_body~load_coins();
        cell metadata = in_msg_body~load_ref();
        
        mint_tokens(to_address, amount, metadata);
        return ();
    }
    
    ;; Burn operation
    if (op == 2) {
        int amount = in_msg_body~load_coins();
        burn_tokens(amount);
        return ();
    }
    
    throw(0xffff);
}
